"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/highlight-words";
exports.ids = ["vendor-chunks/highlight-words"];
exports.modules = {

/***/ "(ssr)/./node_modules/highlight-words/dist/highlight-words.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/highlight-words/dist/highlight-words.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ highlightWords)\n/* harmony export */ });\nlet IDX = 36;\nlet HEX = \"\";\nwhile(IDX--){\n    HEX += IDX.toString(36);\n}\nfunction uid(len = 11) {\n    let str = \"\";\n    let num = len;\n    while(num--){\n        str += HEX[Math.random() * 36 | 0];\n    }\n    return str;\n}\nconst escapeRegexp = (term)=>term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, (char)=>`\\\\${char}`);\nconst termsToRegExpString = (terms)=>terms.replace(/\\s{2,}/g, \" \").split(\" \").join(\"|\");\nconst regexpQuery = ({ terms, matchExactly = false })=>{\n    if (typeof terms !== \"string\") {\n        throw new TypeError(\"Expected a string\");\n    }\n    const escapedTerms = escapeRegexp(terms.trim());\n    return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;\n};\nconst buildRegexp = ({ terms, matchExactly = false })=>{\n    try {\n        const fromString = /^([/~@;%#'])(.*?)\\1([gimsuy]*)$/.exec(terms);\n        if (fromString) {\n            return new RegExp(fromString[2], fromString[3]);\n        }\n        return new RegExp(regexpQuery({\n            terms,\n            matchExactly\n        }), \"ig\");\n    } catch (e) {\n        throw new TypeError(\"Expected terms to be either a string or a RegExp!\");\n    }\n};\nconst hasProp = (prop)=>(obj)=>obj !== null && typeof obj === \"object\" && prop in obj;\nconst hasMatch = hasProp(\"match\");\nconst chunkExists = (chunk)=>typeof chunk !== \"undefined\";\nfunction clip({ curr, next, prev, clipBy = 3 }) {\n    const words = curr.text.split(\" \");\n    const len = words.length;\n    if (curr.match || clipBy >= len) {\n        return curr.text;\n    }\n    const ellipsis = \"...\";\n    if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {\n        if (len > clipBy * 2) {\n            return [\n                ...words.slice(0, clipBy),\n                ellipsis,\n                ...words.slice(-clipBy)\n            ].join(\" \");\n        }\n        return curr.text;\n    }\n    if (chunkExists(next) && hasMatch(next)) {\n        return [\n            ellipsis,\n            ...words.slice(-clipBy)\n        ].join(\" \");\n    }\n    if (chunkExists(prev) && hasMatch(prev)) {\n        return [\n            ...words.slice(0, clipBy),\n            ellipsis\n        ].join(\" \");\n    }\n    return curr.text;\n}\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __spreadProps = (a, b)=>__defProps(a, __getOwnPropDescs(b));\nconst hasLength = (str)=>str.length > 0;\nconst highlightWords = ({ text, query, clipBy, matchExactly = false })=>{\n    const safeQuery = typeof query === \"string\" ? query.trim() : query;\n    if (safeQuery === \"\") {\n        return [\n            {\n                key: uid(),\n                text,\n                match: false\n            }\n        ];\n    }\n    const searchRegexp = buildRegexp({\n        terms: query,\n        matchExactly\n    });\n    return text.split(searchRegexp).filter(hasLength).map((str)=>({\n            // Compose the object for a match\n            key: uid(),\n            text: str,\n            match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n        })).map((chunk, index, chunks)=>__spreadValues(__spreadValues({}, chunk), typeof clipBy === \"number\" && {\n            // We only overwrite the text if there is a clip\n            text: clip(__spreadProps(__spreadValues(__spreadValues({\n                curr: chunk\n            }, index < chunks.length - 1 && {\n                next: chunks[index + 1]\n            }), index > 0 && {\n                prev: chunks[index - 1]\n            }), {\n                // If this wasn't the first chunk, set the previous chunk\n                clipBy\n            }))\n        }));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LXdvcmRzL2Rpc3QvaGlnaGxpZ2h0LXdvcmRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsTUFBTTtBQUNWLElBQUlDLE1BQU07QUFDVixNQUFPRCxNQUFPO0lBQ1pDLE9BQU9ELElBQUlFLFFBQVEsQ0FBQztBQUN0QjtBQUNBLFNBQVNDLElBQUlDLE1BQU0sRUFBRTtJQUNuQixJQUFJQyxNQUFNO0lBQ1YsSUFBSUMsTUFBTUY7SUFDVixNQUFPRSxNQUFPO1FBQ1pELE9BQU9KLEdBQUcsQ0FBQ00sS0FBS0MsTUFBTSxLQUFLLEtBQUssRUFBRTtJQUNwQztJQUNBLE9BQU9IO0FBQ1Q7QUFFQSxNQUFNSSxlQUFlLENBQUNDLE9BQVNBLEtBQUtDLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQ0MsT0FBUyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDO0FBQ3pGLE1BQU1DLHNCQUFzQixDQUFDQyxRQUFVQSxNQUFNSCxPQUFPLENBQUMsV0FBVyxLQUFLSSxLQUFLLENBQUMsS0FBS0MsSUFBSSxDQUFDO0FBQ3JGLE1BQU1DLGNBQWMsQ0FBQyxFQUNuQkgsS0FBSyxFQUNMSSxlQUFlLEtBQUssRUFDckI7SUFDQyxJQUFJLE9BQU9KLFVBQVUsVUFBVTtRQUM3QixNQUFNLElBQUlLLFVBQVU7SUFDdEI7SUFDQSxNQUFNQyxlQUFlWCxhQUFhSyxNQUFNTyxJQUFJO0lBQzVDLE9BQU8sQ0FBQyxDQUFDLEVBQUVILGVBQWVFLGVBQWVQLG9CQUFvQk8sY0FBYyxDQUFDLENBQUM7QUFDL0U7QUFDQSxNQUFNRSxjQUFjLENBQUMsRUFDbkJSLEtBQUssRUFDTEksZUFBZSxLQUFLLEVBQ3JCO0lBQ0MsSUFBSTtRQUNGLE1BQU1LLGFBQWEsa0NBQWtDQyxJQUFJLENBQUNWO1FBQzFELElBQUlTLFlBQVk7WUFDZCxPQUFPLElBQUlFLE9BQU9GLFVBQVUsQ0FBQyxFQUFFLEVBQUVBLFVBQVUsQ0FBQyxFQUFFO1FBQ2hEO1FBQ0Es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Q0MsTUFBTXNELFlBQVksT0FBT0QsVUFBVSxXQUFXQSxNQUFNbEQsSUFBSSxLQUFLa0Q7SUFDN0QsSUFBSUMsY0FBYyxJQUFJO1FBQ3BCLE9BQU87WUFDTDtnQkFDRWIsS0FBS3hEO2dCQUNMb0M7Z0JBQ0FFLE9BQU87WUFDVDtTQUNEO0lBQ0g7SUFDQSxNQUFNZ0MsZUFBZW5ELFlBQVk7UUFBRVIsT0FBT3lEO1FBQU9yRDtJQUFhO0lBQzlELE9BQU9xQixLQUFLeEIsS0FBSyxDQUFDMEQsY0FBY0MsTUFBTSxDQUFDTCxXQUFXTSxHQUFHLENBQUMsQ0FBQ3RFLE1BQVM7WUFDOUQsaUNBQWlDO1lBQ2pDc0QsS0FBS3hEO1lBQ0xvQyxNQUFNbEM7WUFDTm9DLE9BQU92QixlQUFlYixJQUFJdUUsV0FBVyxPQUFPSixVQUFVSSxXQUFXLEtBQUtILGFBQWFJLElBQUksQ0FBQ3hFO1FBQzFGLElBQUlzRSxHQUFHLENBQUMsQ0FBQzNDLE9BQU84QyxPQUFPQyxTQUFXZixlQUFlQSxlQUFlLENBQUMsR0FBR2hDLFFBQVEsT0FBT0ssV0FBVyxZQUFZO1lBQ3hHLGdEQUFnRDtZQUNoREUsTUFBTU4sS0FBS21DLGNBQWNKLGVBQWVBLGVBQWU7Z0JBQ3JEOUIsTUFBTUY7WUFDUixHQUFHOEMsUUFBUUMsT0FBT3ZDLE1BQU0sR0FBRyxLQUFLO2dCQUFFTCxNQUFNNEMsTUFBTSxDQUFDRCxRQUFRLEVBQUU7WUFBQyxJQUFJQSxRQUFRLEtBQUs7Z0JBQUUxQyxNQUFNMkMsTUFBTSxDQUFDRCxRQUFRLEVBQUU7WUFBQyxJQUFJO2dCQUN2Ryx5REFBeUQ7Z0JBQ3pEekM7WUFDRjtRQUNGO0FBQ0Y7QUFFcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXRpbmV0LXZpc2l0LWFwcC8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQtd29yZHMvZGlzdC9oaWdobGlnaHQtd29yZHMubWpzP2FmOGQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IElEWCA9IDM2O1xubGV0IEhFWCA9IFwiXCI7XG53aGlsZSAoSURYLS0pIHtcbiAgSEVYICs9IElEWC50b1N0cmluZygzNik7XG59XG5mdW5jdGlvbiB1aWQobGVuID0gMTEpIHtcbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGxldCBudW0gPSBsZW47XG4gIHdoaWxlIChudW0tLSkge1xuICAgIHN0ciArPSBIRVhbTWF0aC5yYW5kb20oKSAqIDM2IHwgMF07XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuY29uc3QgZXNjYXBlUmVnZXhwID0gKHRlcm0pID0+IHRlcm0ucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAoY2hhcikgPT4gYFxcXFwke2NoYXJ9YCk7XG5jb25zdCB0ZXJtc1RvUmVnRXhwU3RyaW5nID0gKHRlcm1zKSA9PiB0ZXJtcy5yZXBsYWNlKC9cXHN7Mix9L2csIFwiIFwiKS5zcGxpdChcIiBcIikuam9pbihcInxcIik7XG5jb25zdCByZWdleHBRdWVyeSA9ICh7XG4gIHRlcm1zLFxuICBtYXRjaEV4YWN0bHkgPSBmYWxzZVxufSkgPT4ge1xuICBpZiAodHlwZW9mIHRlcm1zICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGVzY2FwZWRUZXJtcyA9IGVzY2FwZVJlZ2V4cCh0ZXJtcy50cmltKCkpO1xuICByZXR1cm4gYCgke21hdGNoRXhhY3RseSA/IGVzY2FwZWRUZXJtcyA6IHRlcm1zVG9SZWdFeHBTdHJpbmcoZXNjYXBlZFRlcm1zKX0pYDtcbn07XG5jb25zdCBidWlsZFJlZ2V4cCA9ICh7XG4gIHRlcm1zLFxuICBtYXRjaEV4YWN0bHkgPSBmYWxzZVxufSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGZyb21TdHJpbmcgPSAvXihbL35AOyUjJ10pKC4qPylcXDEoW2dpbXN1eV0qKSQvLmV4ZWModGVybXMpO1xuICAgIGlmIChmcm9tU3RyaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChmcm9tU3RyaW5nWzJdLCBmcm9tU3RyaW5nWzNdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwUXVlcnkoeyB0ZXJtcywgbWF0Y2hFeGFjdGx5IH0pLCBcImlnXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHRlcm1zIHRvIGJlIGVpdGhlciBhIHN0cmluZyBvciBhIFJlZ0V4cCFcIik7XG4gIH1cbn07XG5cbmNvbnN0IGhhc1Byb3AgPSAocHJvcCkgPT4gKG9iaikgPT4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgcHJvcCBpbiBvYmo7XG5jb25zdCBoYXNNYXRjaCA9IGhhc1Byb3AoXCJtYXRjaFwiKTtcbmNvbnN0IGNodW5rRXhpc3RzID0gKGNodW5rKSA9PiB0eXBlb2YgY2h1bmsgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiBjbGlwKHtcbiAgY3VycixcbiAgbmV4dCxcbiAgcHJldixcbiAgY2xpcEJ5ID0gM1xufSkge1xuICBjb25zdCB3b3JkcyA9IGN1cnIudGV4dC5zcGxpdChcIiBcIik7XG4gIGNvbnN0IGxlbiA9IHdvcmRzLmxlbmd0aDtcbiAgaWYgKGN1cnIubWF0Y2ggfHwgY2xpcEJ5ID49IGxlbikge1xuICAgIHJldHVybiBjdXJyLnRleHQ7XG4gIH1cbiAgY29uc3QgZWxsaXBzaXMgPSBcIi4uLlwiO1xuICBpZiAoY2h1bmtFeGlzdHMobmV4dCkgJiYgY2h1bmtFeGlzdHMocHJldikgJiYgaGFzTWF0Y2gocHJldikgJiYgaGFzTWF0Y2gobmV4dCkpIHtcbiAgICBpZiAobGVuID4gY2xpcEJ5ICogMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4ud29yZHMuc2xpY2UoMCwgY2xpcEJ5KSxcbiAgICAgICAgZWxsaXBzaXMsXG4gICAgICAgIC4uLndvcmRzLnNsaWNlKC1jbGlwQnkpXG4gICAgICBdLmpvaW4oXCIgXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3Vyci50ZXh0O1xuICB9XG4gIGlmIChjaHVua0V4aXN0cyhuZXh0KSAmJiBoYXNNYXRjaChuZXh0KSkge1xuICAgIHJldHVybiBbZWxsaXBzaXMsIC4uLndvcmRzLnNsaWNlKC1jbGlwQnkpXS5qb2luKFwiIFwiKTtcbiAgfVxuICBpZiAoY2h1bmtFeGlzdHMocHJldikgJiYgaGFzTWF0Y2gocHJldikpIHtcbiAgICByZXR1cm4gWy4uLndvcmRzLnNsaWNlKDAsIGNsaXBCeSksIGVsbGlwc2lzXS5qb2luKFwiIFwiKTtcbiAgfVxuICByZXR1cm4gY3Vyci50ZXh0O1xufVxuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IGhhc0xlbmd0aCA9IChzdHIpID0+IHN0ci5sZW5ndGggPiAwO1xuY29uc3QgaGlnaGxpZ2h0V29yZHMgPSAoe1xuICB0ZXh0LFxuICBxdWVyeSxcbiAgY2xpcEJ5LFxuICBtYXRjaEV4YWN0bHkgPSBmYWxzZVxufSkgPT4ge1xuICBjb25zdCBzYWZlUXVlcnkgPSB0eXBlb2YgcXVlcnkgPT09IFwic3RyaW5nXCIgPyBxdWVyeS50cmltKCkgOiBxdWVyeTtcbiAgaWYgKHNhZmVRdWVyeSA9PT0gXCJcIikge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGtleTogdWlkKCksXG4gICAgICAgIHRleHQsXG4gICAgICAgIG1hdGNoOiBmYWxzZVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgY29uc3Qgc2VhcmNoUmVnZXhwID0gYnVpbGRSZWdleHAoeyB0ZXJtczogcXVlcnksIG1hdGNoRXhhY3RseSB9KTtcbiAgcmV0dXJuIHRleHQuc3BsaXQoc2VhcmNoUmVnZXhwKS5maWx0ZXIoaGFzTGVuZ3RoKS5tYXAoKHN0cikgPT4gKHtcbiAgICAvLyBDb21wb3NlIHRoZSBvYmplY3QgZm9yIGEgbWF0Y2hcbiAgICBrZXk6IHVpZCgpLFxuICAgIHRleHQ6IHN0cixcbiAgICBtYXRjaDogbWF0Y2hFeGFjdGx5ID8gc3RyLnRvTG93ZXJDYXNlKCkgPT09IHNhZmVRdWVyeS50b0xvd2VyQ2FzZSgpIDogc2VhcmNoUmVnZXhwLnRlc3Qoc3RyKVxuICB9KSkubWFwKChjaHVuaywgaW5kZXgsIGNodW5rcykgPT4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGNodW5rKSwgdHlwZW9mIGNsaXBCeSA9PT0gXCJudW1iZXJcIiAmJiB7XG4gICAgLy8gV2Ugb25seSBvdmVyd3JpdGUgdGhlIHRleHQgaWYgdGhlcmUgaXMgYSBjbGlwXG4gICAgdGV4dDogY2xpcChfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGN1cnI6IGNodW5rXG4gICAgfSwgaW5kZXggPCBjaHVua3MubGVuZ3RoIC0gMSAmJiB7IG5leHQ6IGNodW5rc1tpbmRleCArIDFdIH0pLCBpbmRleCA+IDAgJiYgeyBwcmV2OiBjaHVua3NbaW5kZXggLSAxXSB9KSwge1xuICAgICAgLy8gSWYgdGhpcyB3YXNuJ3QgdGhlIGZpcnN0IGNodW5rLCBzZXQgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgICBjbGlwQnlcbiAgICB9KSlcbiAgfSkpO1xufTtcblxuZXhwb3J0IHsgaGlnaGxpZ2h0V29yZHMgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIklEWCIsIkhFWCIsInRvU3RyaW5nIiwidWlkIiwibGVuIiwic3RyIiwibnVtIiwiTWF0aCIsInJhbmRvbSIsImVzY2FwZVJlZ2V4cCIsInRlcm0iLCJyZXBsYWNlIiwiY2hhciIsInRlcm1zVG9SZWdFeHBTdHJpbmciLCJ0ZXJtcyIsInNwbGl0Iiwiam9pbiIsInJlZ2V4cFF1ZXJ5IiwibWF0Y2hFeGFjdGx5IiwiVHlwZUVycm9yIiwiZXNjYXBlZFRlcm1zIiwidHJpbSIsImJ1aWxkUmVnZXhwIiwiZnJvbVN0cmluZyIsImV4ZWMiLCJSZWdFeHAiLCJlIiwiaGFzUHJvcCIsInByb3AiLCJvYmoiLCJoYXNNYXRjaCIsImNodW5rRXhpc3RzIiwiY2h1bmsiLCJjbGlwIiwiY3VyciIsIm5leHQiLCJwcmV2IiwiY2xpcEJ5Iiwid29yZHMiLCJ0ZXh0IiwibGVuZ3RoIiwibWF0Y2giLCJlbGxpcHNpcyIsInNsaWNlIiwiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZlByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsIl9fZ2V0T3duUHJvcERlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fcHJvcElzRW51bSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19kZWZOb3JtYWxQcm9wIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3NwcmVhZFZhbHVlcyIsImEiLCJiIiwiY2FsbCIsIl9fc3ByZWFkUHJvcHMiLCJoYXNMZW5ndGgiLCJoaWdobGlnaHRXb3JkcyIsInF1ZXJ5Iiwic2FmZVF1ZXJ5Iiwic2VhcmNoUmVnZXhwIiwiZmlsdGVyIiwibWFwIiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwiaW5kZXgiLCJjaHVua3MiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight-words/dist/highlight-words.mjs\n");

/***/ })

};
;